# Chapter 6: Pointers

## A Quick Pointer Primer

A `pointer` is a variable that contains the address of where another variable is
stored.

The zero value for a pointer is `nil`. `nil` is an untyped identifier that represents
the lack of a value for certain types. In Go, `nil` isn't another name for the value
0.

Pointer arithmetic isn't allowed in Go.

!!! Note "unsafe"

    The Go standard library does have an `unsafe` package that lets you do some low-level
    operations on data structures. While pointer manipulation is used in C for common
    operations, it is exceedingly rare for Go developers to use `unsafe`.

    `unsafe` is covered in
    [Chapter 16: Reflect, Unsafe, and Cgo > unsafe is Unsafe](ch16.md#unsafe-is-unsafe).

The `&` is the address operator. It precedes a variable or addressable expression and
returns the address where the value is stored.

```go
x := "hello"
pointerToX := &x

type Person struct {
    Name string
}
person := Person{Name: "Alice"}
pointerToName := &person.Name  // addressable expression

numbers := [3]int{1, 2, 3}
pointerToFirst := &numbers[0]  // addressable expression
```

The `*` is the indirection operator. It precedes a variable of pointer type and returns
the pointed-to value. This is called *dereferencing*. Go will panic if a `nil` pointer
is dereferenced.

```go
x := 10
pointerToX := &x
fmt.Println(pointerToX)  // prints a memory address
fmt.Println(*pointerToX) // prints 10
z := 5 + *pointerToX
fmt.Println(z)           // prints 15
```

A pointer type is a type that represents a pointer. It's written with a `*` before a
type name. Any type can be used.

```go
x := 10
var pointerToX *int
pointerToX = &x
```

The built-in function `new` (which is rarely used) creates a pointer variable. It
returns a pointer to a zero-value instance of the provided type:

```go
var x = new(int)
fmt.Println(x == nil) // prints false
fmt.Println(*x)       // prints 0
```

You can't use the address operator on a primitive type literal (numbers, booleans,
and strings) or a constant because they don't have memory addresses. When you need a
pointer to a primitive type, make a variable and point to it:

```go
var y string
z := &y
```

Use a helper function to turn a constant value into a pointer:

```go
func makePointer[T any](value T) *T {
    return &value
}

ptr := makePointer(42)     // returns *int pointing to 42
strPtr := makePointer("hi") // returns *string pointing to "hi"
```

## Don't Fear the Pointers

Go gives you the choice to use pointers or values for both primitives and structs.
Most of the time, you should use a value. Values make it easier to understand how and
when your data is modified.

## Pointers Indicate Mutable Parameters

Go developers use pointers to indicate that a parameter is mutable.

Since Go is a call-by-value language, the values passed to a function are copies. For
nonpointer types like primitives, structs, and arrays, this means that the called
function can't modify the original. Since the called function has a copy of the
original value, immutability is guaranteed.

However, if a pointer is passed to a function, the function gets a copy of the
*pointer*. This still points to the original value, which means that the original value
can be mutated by the called function.

This has two implications:

1. Since the *pointer* is passed by value, when you pass a `nil` pointer to a
   function, you can't make the original pointer non-`nil`

    ```go
    func failedUpdate(px *int) {
        x := 10
        px = &x
    }

    func main() {
        var f *int // f is nil
        failedUpdate(f)
        fmt.Println(f) // prints nil
    }
    ```

2. The called function must dereference the pointer to mutate the value

    ```go
    func failedUpdate(px *int) {
        x2 := 20
        px = &x2
    }

    func update(px *int) {
        *px = 20
    }

    func main() {
        x := 10
        failedUpdate(&x)
        fmt.Println(x) // prints 10
        update(&x)
        fmt.Println(x) // prints 20
    }
    ```

## Pointers Are a Last Resort

Favor value types over pointer types when returning values from functions. Mutating
function parameters via pointers should be rare.

When working with interfaces, be aware that if you need to modify a value through an
interface variable, the interface must hold a pointer to that value. Methods with
pointer receivers can only be called on the interface when it contains a pointer.
See [Chapter 7: Types, Methods, and Interfaces](ch07.md) for more details on pointer
receivers and interfaces.

Use a pointer type as a return type in these situations:

1. **Factory functions for mutable types** - when creating objects designed to be
   modified after creation:

   ```go
   func NewBuffer() *bytes.Buffer {
       return &bytes.Buffer{}
   }
   ```

2. **Method chaining** - when methods return the receiver to allow chaining:

   ```go
   func (b *Builder) WriteString(s string) *Builder {
       // ... write string ...
       return b  // allows chaining: b.WriteString("a").WriteString("b")
   }
   ```

!!! note "Prefer the comma ok idiom over nil pointers"

    If you need to indicate "not found" or "no value," prefer returning a value type
    with a boolean rather than a pointer that could be `nil`:

    ```go
    // Preferred: comma ok idiom
    func FindUser(id int) (User, bool) {
        // return User{}, false if not found
    }

    // Avoid: nil pointer return
    func FindUser(id int) *User {
        // return nil if not found
    }
    ```

    Return a pointer that could be `nil` only when the type is always used as a pointer
    (like results from database queries) or when implementing an interface that requires it.

Some data types used with concurrency (like `sync.Mutex`) must always be passed as
pointers to work correctly.

## Pointer Passing Performance

Don't choose pointers over values for performance reasons without measuring first.

**Pointer size is constant:** A pointer is the same size (typically 8 bytes on 64-bit
systems) regardless of what it points to. Passing a pointer is always fast.

**Value size varies:** Passing a value type copies all the data. Small values (a few
dozen bytes) are very fast to copy. Large values (megabytes) take longer.

**Small values favor value types:** For small data structures, passing by value is
actually slightly faster than passing a pointer because:

- No indirection is needed to access the data
- Better CPU cache locality
- Less pressure on the garbage collector

**When to consider pointers for performance:**

- Passing very large data structures (many kilobytes or megabytes)
- Frequently passing the same large struct between many functions
- Profiling shows copying is a bottleneck

For the vast majority of cases, the performance difference is negligible. Choose
based on semantics (mutability vs. immutability) rather than performance, and only
optimize with pointers if profiling shows it's necessary.

## The Zero Value Versus No Value

Sometimes you need to distinguish between a variable set to its zero value and a
variable that hasn't been set at all. For example:

- An integer set to `0` versus an integer that was never assigned
- A string set to `""` versus a string that's missing
- A boolean set to `false` versus a boolean that's unspecified

### Option 1: Use a pointer (only if the value will be modified)

A `nil` pointer can represent "no value":

```go
type Person struct {
    Name string
    Age  *int  // nil means age not provided, 0 means age is actually 0
}

p := Person{Name: "Alice", Age: nil}  // age not provided
age := 0
p2 := Person{Name: "Bob", Age: &age}  // age is explicitly 0
```

However, remember that you can't set a `nil` pointer's value inside a function—there's
nowhere to store it:

```go
func setDefault(age *int) {
    if age == nil {
        // Cannot do: *age = 18  // This would panic!
        // The pointer itself is passed by value, so reassigning it here will not help
    }
}
```

### Option 2: Use the comma ok idiom (preferred for read-only values)

If you don't need to modify the value, prefer returning a value type with a boolean:

```go
type Person struct {
    Name    string
    Age     int
    HasAge  bool  // true if Age was set
}

// Or use comma ok when reading:
func GetAge() (int, bool) {
    // return age, true if set
    // return 0, false if not set
}
```

!!! tip "Guideline"

    Some libraries like `encoding/json` use pointer fields to represent nullable
    values. The `database/sql` package provides types like `sql.NullString` and
    `sql.NullInt64` that combine a value with a boolean flag to indicate validity.

    Resist using pointer fields just to indicate "no value." Use pointers only
    when you need to modify the value. For read-only optional values, use the comma ok
    idiom or a dedicated nullable type instead.

## The Difference Between Maps and Slices

Both maps and slices behave like reference types when passed to functions, but for
different reasons and with different limitations.

### How Maps Work

Maps are implemented as pointers to structs. When you pass a map to a function, any
changes made to the map's contents are reflected in the original:

```go
func modifyMap(m map[string]int) {
    m["key"] = 42  // This changes the original map
}

func main() {
    myMap := map[string]int{"key": 10}
    modifyMap(myMap)
    fmt.Println(myMap["key"])  // prints 42
}
```

However, using maps as function parameters or return values has drawbacks:

1. **Poor type information** - `map[string]int` doesn't tell you what keys are valid
   or what they represent. You must read the code to understand the structure.
2. **Unclear mutability** - It's not obvious whether the map is meant to be modified
   or is read-only.

**Guideline:** Prefer structs over maps when the keys are known at compile time. Use
maps only when keys are dynamic or determined at runtime.

### How Slices Work

Slices are implemented as a struct containing three fields:

- Length (number of elements currently in use)
- Capacity (total available space)
- Pointer to the underlying array

When you pass a slice to a function, you can modify the existing elements, but you
can't change the slice's length, capacity, or reallocate its underlying array:

```go
func modifySlice(s []int) {
    s[0] = 100        // This changes the original slice's data
    s = append(s, 5)  // This only affects the local copy
}

func main() {
    mySlice := []int{1, 2, 3}
    modifySlice(mySlice)
    fmt.Println(mySlice)  // prints [100 2 3], not [100 2 3 5]
}
```

To modify the slice structure itself (length/capacity), return a new slice:

```go
func appendToSlice(s []int, val int) []int {
    return append(s, val)
}

func main() {
    mySlice := []int{1, 2, 3}
    mySlice = appendToSlice(mySlice, 5)
    fmt.Println(mySlice)  // prints [1 2 3 5]
}
```

## Slices as Buffers

The ability to modify slice contents (but not size) when passing to functions makes
slices ideal for reusable buffers, reducing memory allocations.

Even though Go is garbage-collected, writing idiomatic Go means avoiding unnecessary
allocations. Rather than creating a new slice allocation each time you read from a
data source, create a slice of bytes once and reuse it as a buffer:

```go
file, err := os.Open("data.txt")
if err != nil {
    log.Fatal(err)
}
defer file.Close()

// Create a reusable buffer once
buffer := make([]byte, 1024)

for {
    // Read into the existing buffer (no new allocation)
    bytesRead, err := file.Read(buffer)
    if err != nil {
        if err != io.EOF {
            log.Printf("Error reading file: %v", err)
        }
        break
    }

    // Process the data in buffer[:bytesRead]
    processData(buffer[:bytesRead])

    // The buffer can be reused in the next iteration
}

func processData(data []byte) {
    // data shares the same underlying array as buffer
    // We can read from it but shouldn't modify it if we want to preserve the buffer
    fmt.Printf("Processing %d bytes\n", len(data))
}
```

The `file.Read()` method takes a `[]byte` parameter and modifies its contents with
data read from the file. It returns the number of bytes read and any error encountered. By
reusing the same buffer, we avoid allocating a new slice on every read operation,
significantly reducing garbage collection pressure in loops that process large
amounts of data.

## Reducing the Garbage Collection Workload

Having a garbage collector doesn't mean you should create unnecessary garbage. Go
encourages sparse pointer use to reduce the garbage collector's workload by keeping
as much data as possible on the stack rather than the heap.

### Stack vs. Heap

**Stack:** A contiguous block of memory where allocation and deallocation are fast and
simple. Data on the stack is accessed sequentially, which is orders of magnitude
faster than random heap access.

**Heap:** Dynamic memory requiring garbage collection. The garbage collector takes time
to identify and free unused memory.

### When Data Goes on the Stack

Go uses *escape analysis* at compile time to determine whether data can safely live
on the stack or must be allocated on the heap. Go stores data on the stack when the
size is known at compile time and the data doesn't escape the function.

For example:

```go
func stackExample() {
    x := 10              // x is on the stack
    y := Person{Age: 30} // y is on the stack
    // Both x and y are freed when the function returns
}

func heapExample() *Person {
    p := Person{Age: 30} // p escapes, so it's allocated on the heap
    return &p            // Returning pointer moves p to heap
}
```

!!! tip "Viewing Escape Analysis"

    You can see the compiler's escape analysis decisions by building with the flag
    `-gcflags="-m"`:

    ```bash
    go build -gcflags="-m" myprogram.go
    ```

    This shows which variables escape to the heap and why.

### Practical Implications

**Prefer values over pointers** when the data doesn't need to be shared or modified
outside the function. This keeps data on the stack, reducing garbage collection
pressure.

**Use slices of values** (structs or primitives) when possible. Their data is laid out
sequentially in memory for rapid access, and if the slice doesn't escape, the
underlying array can live on the stack.

## Tuning the Garbage Collector

The Go runtime provides two settings to control garbage collection behavior: `GOGC`
and `GOMEMLIMIT`.

### GOGC: Controlling Collection Frequency

`GOGC` determines when the next garbage collection cycle runs based on heap growth:

```text
Target Heap Size = Current Heap Size + (Current Heap Size × GOGC / 100)
```

**Default value:** `GOGC=100` means the heap must roughly double before triggering the
next collection.

**Effects:**

- Lower values (for example, `GOGC=50`): more frequent GC, less memory, more CPU time
- Higher values (for example, `GOGC=200`): less frequent GC, more memory, less CPU time
- Doubling `GOGC` roughly halves CPU time spent on GC
- Setting `GOGC=off` disables GC entirely (not recommended for long-running processes)

### GOMEMLIMIT: Setting Memory Limits

`GOMEMLIMIT` sets a soft limit on total memory usage (similar to Java's `-Xmx`).

**Default:** Disabled (technically `math.MaxInt64`)

**Format:** Bytes with optional suffixes: `B`, `KiB`, `MiB`, `GiB`, `TiB`

- Example: `GOMEMLIMIT=3GiB` limits memory to 3 gibibytes (3,221,225,472 bytes)
- Note: Go uses binary units (powers of 1024), not decimal units (powers of 1000)
- `1 GiB = 1024 MiB = 1,073,741,824 bytes`

**Why use it:**

- Prevents memory spikes from exceeding available RAM
- Avoids slow disk swapping or program crashes
- Particularly useful in containers or VMs with limited memory

**Important notes:**

- This is a *soft* limit that can be exceeded to prevent thrashing
- Set it below your absolute maximum to leave spare capacity
- If the runtime detects thrashing (rapid GC cycles making no progress), it will
  exceed the limit rather than freeze the program

### Using GOGC and GOMEMLIMIT Together

**Don't set `GOGC=off` with `GOMEMLIMIT`** - This trades frequent short pauses for
infrequent long pauses, creating inconsistent response times in web services.

**Best practice:** Use both settings together to ensure reasonable GC pacing while
respecting memory limits.

!!! tip "Further Reading"

    For detailed information on tuning Go's garbage collector, read
    ["A Guide to the Go Garbage Collector"](https://go.dev/doc/gc-guide) from the Go
    development team.
