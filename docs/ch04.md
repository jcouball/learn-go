# Chapter 4: Blocks, Shadows, and Control Structures

## Scope

Scope defines the region of code where a variable/identifier is accessible.

In Go, there are four scoping levels:

- **Universe/Predeclared scope**: Built-in identifiers like `int`, `string`, `true`,
  `false`, `nil`, `make`, `len`, etc. They're available everywhere. Go considers
  these pre-defined identifiers instead of keywords.
- **Package scope**: Variables, constants, types, and functions declared outside any
  function. Accessible throughout the entire package. Capitalized names are
  accessible from other packages via an import statement.
- **File scope**: Import statements are file-scoped. Each file in a package can have
  different imports, and imported package names are only accessible within that file.
- **Local scope**: Variables declared inside functions, including parameters. Only
  accessible within that function or block. Inner blocks can shadow outer scopes (see
  [Shadowing Variables](#shadowing-variables) below).

Examples of scopes:

```go
package main  // Package scope starts

import "fmt"  // File scope (import)

var GlobalVar = 10  // Package scope

func example(param int) {  // param is local scope
    localVar := 20  // Local scope

    if true {
        innerVar := 30  // Local scope (nested block)
        fmt.Println(param, localVar, innerVar)
    }
    // innerVar not accessible here
}
```

## Blocks

Blocks define where scopes begin and end. You can think of blocks as the mechanism
that creates and delimits scopes.

Blocks can be nested. Nested (or inner) blocks can access identifiers defined in
ancestor (or outer) blocks but not vice versa.

```go
func example() {
    x := 10  // outer block

    if true {
        y := 20      // inner block can access x
        fmt.Println(x, y)  // ✓ works
    }

    fmt.Println(x)  // ✓ works
    fmt.Println(y)  // ✗ compile error - outer can't access y
}
```

Go has many types of blocks:

1. Explicit blocks (with `{}`):
    - Function bodies
    - Compound statements (`if`, `for`, `switch`, `select`)
    - Standalone block statements

2. Implicit blocks (no braces):
    - **Universe block**: Encompasses all Go source code
    - **Package block**: All source files in a package
    - **File block**: Each individual file
    - **Clause blocks**: Each `case` or `default` clause in `switch` or `select`
      creates its own scope
    - **Short statement blocks**: The scope created by short declarations in `if`,
      `for`, `switch` statements

Examples of blocks and nesting:

```go
// Package block (implicit)
package main

var pkgVar = 1  // In package block

// File block - imports are file-scoped
import "fmt"

func example() {  // Function block (explicit)
    if x := 5; x > 0 {  // x in implicit block of if statement
        y := 10  // y in explicit if body block

        switch z := x; z {  // z in implicit switch block
        case 5:  // case clause implicit block
            a := 20  // a only in this case
        default:  // default clause implicit block
            b := 30  // b only in default
        }
    }

    {  // Standalone explicit block
        isolated := 100
    }
}
```

## Shadowing Variables

A shadowing variable is a variable that has the same name as a variable in an outer
block. For as long as the shadowing variable exists, you can't access the shadowed
variable. The shadowing starts at the point the identifier is declared within its
block, not necessarily at the beginning of the block.

Go follows lexical scoping rules where:

- Nested (or inner) blocks can access identifiers from ancestor (or outer) blocks
- Identifiers defined in inner blocks shadow identifiers of the same name from outer
  blocks

```go
func main() {
    x := 10
    if x > 5 {
        fmt.Println(x) // Output: 10
        x := 5         // x is shadowed starting here
        fmt.Println(x) // Output: 5
    }
    fmt.Println(x) // Output: 10
}
```

Note that `:=` only reuses variables that are declared in the *current* block. When
using `:=`, make sure that you don’t have any variables from an outer scope on the
lefthand side unless you intend to shadow them.

Be careful not to shadow package names. Package names, like other identifiers, can be
shadowed:

```go
func main() {
    x := 10
    fmt.Println(x) // Output: 10
    fmt := "oops"
    fmt.Println(fmt) // Compile error:
    // fmt.Println undefined (type string has no field or method Println)
}
```

You must be very careful to never redefine any identifiers in the universe block.
These include built-in types (like int and string), constants (like true and false),
and functions (like make or close).

```go
fmt.Println(true) // Output: true
true := 10
fmt.Println(true) // Output: 10
```

## Simple Statements

A simple statement is a single-line operation that doesn't involve control flow. Go's
control structures (`if`, `for`, `switch`) allow an optional simple statement before
their main clause.

Types of simple statements:

- Short variable declaration: `x := 5`
- Assignment: `x = 10`
- Increment/decrement: `i++`, `i--`
- Function call: `fmt.Println("hello")`
- Send on channel: `ch <- value`
- Empty statement

**Not** simple statements: `if`, `for`, `switch`, `return`, `defer`, `go`, `var`,
`const`, `type`

Best practice: Only use short variable declarations (`:=`) in control structure
initializers. Other simple statements, while allowed, make code confusing.

```go
// Idiomatic: short variable declaration
if n := rand.Intn(10); n == 0 {
    fmt.Println("zero")
}

// Valid but confusing: other simple statements
if i++; i > 10 { }           // Don't do this
if fmt.Println("hi"); true { }  // Don't do this
```

## if

In Go, if statements look a lot like other languages with the following differences:

- you don't put parenthesis around the condition of the if statement
- you can add a [simple statement](#simple-statements) before the condition
- braces are required even for single-line if bodies
- the condition MUST evaluate to a `bool` (there are no truthy/falsy values like
  Python/Ruby/JavaScript)

Example of a basic if statement:

```go
n := rand.Intn(10)
if n == 0 {
    fmt.Println("That's too low")
} else if n > 5 {
    fmt.Println("That's too big:", n)
} else {
    fmt.Println("That's a good number:", n)
}
```

Example with a simple statement that declares a variable scoped to the if and else
blocks:

```go
if n := rand.Intn(10); n == 0 {
    fmt.Println("That's too low")
} else if n > 5 {
    fmt.Println("That's too big:", n)
} else {
    fmt.Println("That's a good number:", n)
}
// n is out of scope outside the if statement
```

## for

`for` is the only looping keyword in the language. Go accomplishes this by using the
`for` keyword in four formats:

- A complete, C-style `for`
- A condition-only `for`
- An infinite `for`
- `for-range`

### Complete `for` Statement

The complete `for` looks a lot like the `for` statement from C, Java, or Javascript:

```go
for i := 0; i < 10; i++ {
    fmt.Println(i)
}
```

The `for` statement has three parts, separated by semicolons followed by a body block
enclosed in braces.

The three parts are initialization, condition, and increment. Each of these sections
is optional, but the semicolon must still be given. There is no parenthesis around
these parts.

```go
for initialization; condition; increment {
    body
}
```

In the initialization section, you:

- must use `:=` to initialize the variables since `var` isn't legal here
- may shadow a variable here

Variables declared in the initialization are scoped to the `for` loop block:

```go
for i := 0; i < 10; i++ {
    fmt.Println(i)
}
// i is out of scope here
```

The condition must evaluate to a `bool`. The loop body is executed as long as the
expression evaluates to true.

Any [simple statement](#simple-statements) is valid in the increment section, but you
usually see an increment operation like `i++`. This is run immediately after the loop
body and before the condition is evaluated again.

### Condition-Only `for` Statement

A `for` statement with a condition-only and no semi-colons functions like a `while`
statement found in other languages:

```go
i := 1
for i < 100 {
    fmt.Println(i)
    i = i * 2
}
```

### Infinite `for` Statement

A `for` statement with no semi-colon separated parts loops forever:

```go
 // Outputs "Hello" forever
for {
    fmt.Println("Hello")
}
```

### break and continue

The `break` statement exits a loop immediately.

The `continue` statement skips the rest of the loop body and proceeds to the next
iteration. In a complete `for` loop, the increment runs before the condition is
checked again.

Example using `break` to exit early when a value is found:

```go
for i := 1; i <= 10; i++ {
    if i == 5 {
        fmt.Println("Found 5, stopping!")
        break
    }
    fmt.Println(i)
}
// Output: 1 2 3 4 Found 5, stopping!
```

Example using `continue` to skip certain iterations:

```go
for i := 1; i <= 5; i++ {
    if i%2 == 0 {
        continue  // Skip even numbers
    }
    fmt.Println(i)
}
// Output: 1 3 5
```

#### Nested Loops

When loops are nested, `break` and `continue` only affect the innermost loop they
appear in. The outer loop continues normally.

```go
for i := 1; i <= 3; i++ {
    fmt.Printf("Outer loop: i=%d\n", i)
    for j := 1; j <= 3; j++ {
        if j == 2 {
            continue  // Skips to next j iteration, doesn't affect outer loop
        }
        if j == 3 && i == 2 {
            break  // Exits inner loop only when i=2, outer loop continues
        }
        fmt.Printf("  Inner loop: j=%d\n", j)
    }
}
// Output:
// Outer loop: i=1
//   Inner loop: j=1
//   Inner loop: j=3
// Outer loop: i=2
//   Inner loop: j=1
// Outer loop: i=3
//   Inner loop: j=1
//   Inner loop: j=3
```

To break out of an outer loop from within an inner loop, use labeled breaks (see
[Labels](#labels) below).

#### Using continue for Cleaner Code

Go encourages nesting as few layers deep as possible. The following code is less
idiomatic:

```go
for i := 1; i <= 100; i++ {
    if i%3 == 0 {
        if i%5 == 0 {
            fmt.Println("FizzBuzz")
        } else {
            fmt.Println("Fizz")
        }
    } else if i%5 == 0 {
        fmt.Println("Buzz")
    } else {
        fmt.Println(i)
    }
}
```

than this code:

```go
for i := 1; i <= 100; i++ {
    if i%3 == 0 && i%5 == 0 {
        fmt.Println("FizzBuzz")
        continue
    }
    if i%3 == 0 {
        fmt.Println("Fizz")
        continue
    }
    if i%5 == 0 {
        fmt.Println("Buzz")
        continue
    }
    fmt.Println(i)
}
```

Lining up the conditions improves the layout and makes the code easier to understand.

### for-range

The `for-range` loop iterates over elements in some of Go's built-in types such as
strings, arrays, slices, maps, and channels. This section will cover all but channels
which will be described in [Chapter 12: Concurrency in Go > Using for-range and
Channels](ch12#using-for-range-and-channels).

Starting in Go 1.23, you can define custom iterators for user-defined types using the
`iter.Seq[V]` or `iter.Seq2[K, V]`.

`break` and `continue` work in `for-range` loops like any other `for` loop.

The value yielded by the `for-range` loop is a copy of the value from the compound
type to the value variable. Modifying the value variable won't modify the value in
the compound type:

```go
vals := []int{1, 2, 3}
for _, v := range vals {
    v = v * 2  // This modifies the copy, not the slice
}
fmt.Println(vals)  // Output: [1 2 3] - original unchanged
```

#### Iterating over arrays and slices

Iterating over arrays works the same as iterating over slices but is rarely used
since arrays are rarely used.

The code:

```go
evenVals := []int{2, 4, 6}

// the for-range loop returns two values: i (index) and v (value):
for i, v := range evenVals {
    fmt.Println(i, v)
}
```

produces the output:

```text
0 2
1 4
2 6
```

#### Iterating over maps

When iterating over maps with `for-range`, the key and value are returned (instead of
the index and value).

!!! note "Iteration order"

    When iterating over a map, the order of keys and values is
    random. This is a security feature.

```go
m := map[string]int{
    "James": 58,
    "Frank": 62,
}

for k, v := range m {
    fmt.Println(k, v)
}
```

produces the output:

```text
James 58
Frank 62
```

#### Iterating over strings

`for-range` iterates over the runes in a string. For instance:

```go
str := "apple_π!"
for i, r := range str {
    fmt.Println(i, r, string(r))
}
```

produces the output:

```text
0 97 a
1 112 p
2 112 p
3 108 l
4 101 e
5 95 _
6 960 π
8 33 !
```

If the `for-range` loop encounters a byte that doesn't represent a valid UTF-8 code
point, the Unicode replacement character (hex value `0xfffd`) is returned instead.

#### Ignoring the Index/Key or Value

When ranging over slices, arrays, maps, and strings, `for-range` returns two values.
If you don't need the first value (the index or key), use an underscore (`_`) as the
variable name to ignore it. If you don't need the second value, simply omit it.

Ignoring the index when iterating over a slice:

```go
evenVals := []int{2, 4, 6}
for _, v := range evenVals {
    fmt.Println(v)  // prints: 2, 4, 6
}
```

Ignoring the value when iterating over a slice (only iterate over indices):

```go
evenVals := []int{2, 4, 6}
for i := range evenVals {
    fmt.Println(i)  // prints: 0, 1, 2
}
```

Ignoring the value when iterating over a map (common when using a map as a set):

```go
uniqueNames := map[string]bool{"James": true, "Frank": true}
for k := range uniqueNames {
    fmt.Println(k)  // prints keys in random order
}
```

Ignoring the byte position when iterating over a string:

```go
str := "Hello"
for _, r := range str {
    fmt.Printf("%c ", r)  // prints: H e l l o
}
```

### Labels

`break` and `continue` apply to the inner-most loop containing them. A label may be
given to either of these statements to apply to an outer loop.

Labels are uncommon but occasionally useful. For simple cases, extracting nested
loops into a separate function and using `return` may be clearer. For complex
algorithms, labeled `break` and `continue` can make the intent more explicit.

Labels are scoped to the function they're declared in.

#### break with a Label

`break` with a label is used to exit multiple levels of nested loops at once. This is
commonly used when searching for a value in a 2D structure and you want to stop all
iteration once found.

Example - finding a value in a 2D slice:

```go
func findValue(matrix [][]int, target int) (row, col int, found bool) {
outer:
    for i, rowVals := range matrix {
        for j, val := range rowVals {
            if val == target {
                row, col, found = i, j, true
                break outer  // Exit both loops immediately
            }
        }
    }
    return row, col, found
}

// Usage
matrix := [][]int{
    {1, 2, 3},
    {4, 5, 6},
    {7, 8, 9},
}

r, c, found := findValue(matrix, 5)
if found {
    fmt.Printf("Found at [%d][%d]\n", r, c)  // Output: Found at [1][1]
}
```

Without the label, you would need a flag variable to track whether to exit the outer
loop, making the code more complex.

#### continue with a Label

`continue` with a label skips to the next iteration of an outer loop. This is useful
when you want to skip processing the rest of the inner loop items and move to the
next outer loop iteration.

Example - skipping an entire order when an invalid item is found:

```go
orders := [][]string{
    {"apple", "banana", "cherry"},
    {"date", "INVALID", "fig"},
    {"grape", "kiwi"},
}

processedOrders := 0

outer:
    for orderNum, items := range orders {
        for _, item := range items {
            if item == "INVALID" {
                fmt.Printf("Order %d skipped\n", orderNum)
                continue outer  // Skip to next order
            }
            fmt.Printf("Processing: %s\n", item)
        }
        processedOrders++
        fmt.Printf("Order %d completed\n", orderNum)
    }

fmt.Printf("Processed %d/%d orders\n", processedOrders, len(orders))
```

The code after the inner loop only runs if all items in the order were valid.

### Choosing the Right for Statement

Use a `for-range` loop when iterating over the built-in compound types (slices,
arrays, maps, strings, channels). It avoids index arithmetic and off-by-one errors.
When iterating over strings, `for-range` is essential since it iterates over runes,
not bytes.

Use the complete `for` loop when you need explicit control over iteration: starting
at a position other than zero, using a custom increment, or iterating backwards. It
clearly communicates the start, end, and step of the iteration.

Use the condition-only `for` loop when you're looping until a condition changes but
don't have a predictable number of iterations. For example, reading until EOF,
processing until a threshold is reached.

Use the infinite `for` loop for ongoing processes that run until explicitly broken.
For example, servers, event loops, retry logic with timeout.

## switch

This section covers *expression switch* and *blank switch* statements. *type switch*
statements are covered in [Chapter 7: Types, Methods, and Interfaces > Type
Assertions and Type Switches](ch07#type-assertions-and-type-switches).

Here is an example `switch` statement:

```go
scores := []int{42, 95, 67, 100, 15, 88, 73}
for _, score := range scores {
    switch grade := score / 10; grade {
    case 10, 9:
        fmt.Println(score, "is an excellent score!")
    case 8:
        bPercentage := grade * 10
        fmt.Println(score, "earned a solid B, which is at least", bPercentage, "percent")
    case 7, 6:
    default:
        fmt.Println(score, "needs improvement")
    }
}
```

Running this example gives the following output:

```text
42 needs improvement
95 is an excellent score!
100 is an excellent score!
15 needs improvement
88 earned a solid B, which is at least 80 percent
```

In this example, the value being switched on is an integer. You can switch on any
type that can be compared with `==`.

Just like an `if` statement:

- Don't put parenthesis around the value being compared in a `switch`.
- A variable can be declared (`grade` in the example). This value is only accessible
  within the `switch` block (all `case` clauses).

All `case` clauses, including the optional `default` clause, are contained in a set
of braces.

Don't put braces around the contents of the `case` clauses. The contents of a `case`
clause can contain multiple lines. Each `case` clause's contents form a new block,
which means variables declared within a `case` clause are only scoped to that `case`
clause.

By default, `case` execution doesn't fall through to the next case. A `break` isn't
needed at the end of each `case`. However, a `break` statement can be used to exit
the case early. When using `break` in a `switch` statement, be careful if that
`switch` statement is inside a `for` loop. If you intend to `break` out of a `for`
loop within a `switch` statement, you will need to use a `break` with a label.

Separate multiple matches for a `case` clause with commas like `case 9, 10:` in the
example.

Empty cases do nothing without automatically falling through to the next case like
`case 7, 6:` in the example.

Go does include a `fallthrough` keyword, which makes execution continue to the next
case unconditionally. This is rarely used and should be avoided in favor of clearer
logic—if you find yourself needing it, consider restructuring your code or combining
case conditions with commas instead.

### Blank Switches

Go allows writing a `switch` statement that doesn't specify the value being compared.
This is called a *blank switch*.

A blank `switch` requires a boolean comparison for each `case`. Here is the example
above rewritten as a blank `switch`:

```go
scores := []int{42, 95, 67, 100, 15, 88, 73}
for _, score := range scores {
    switch {
    case score >= 90:
        fmt.Println(score, "is an excellent score!")
    case score >= 80:
        fmt.Println(score, "earned a solid B, which is at least 80 percent")
    case score >= 60:
    default:
        fmt.Println(score, "needs improvement")
    }
}
```

Which would output the same thing as the previous example:

```text
42 needs improvement
95 is an excellent score!
100 is an excellent score!
15 needs improvement
88 earned a solid B, which is at least 80 percent
```

If you write a blank switch where all the cases are equality comparisons to the same
variable, you should consider writing an expression switch instead.

### Choosing Between if and switch

Favor blank `switch` statements over `if/else` chains when there are multiple related
cases. Using a `switch` makes the comparisons more visible and reinforces that they
are a related set of concerns.

## goto

In Go, the `goto` statement jumps to a labeled line of code within the same function.
Labels are identifiers followed by a colon and are typically written in uppercase to
make them stand out.

Go won't allow a jump that would:

- Skip over variable declarations
- Jump into an inner or parallel block
- Jump into a different function

Try very hard to avoid using `goto`. Labeled `break` and `continue` statements (see
[Labels](#labels)) are almost always a better choice for exiting nested loops. In
rare situations where centralized cleanup or error handling logic is needed, `goto`
can make code more readable than deeply nested conditionals.

The most legitimate use of `goto` is for centralized cleanup in functions with
multiple exit points:

```go
func processFile(filename string) error {
    file, err := os.Open(filename)
    if err != nil {
        goto CLEANUP
    }

    data, err := readData(file)
    if err != nil {
        goto CLEANUP
    }

    err = processData(data)
    if err != nil {
        goto CLEANUP
    }

CLEANUP:
    if file != nil {
        file.Close()
    }
    return err
}
```

This pattern is less common in modern Go since `defer` handles cleanup more
elegantly. `defer` is described in [Chapter 5: Functions > defer](ch05#defer). Using
`goto` to break out of nested loops is also discouraged since labeled `break`
accomplishes the same thing more clearly.
