# Chapter 5: Functions

## Declaring and Calling Functions

Every Go program starts with a `main` function. The main function takes no parameters
and returns no values.

Here is a simple function declaration:

```go
func calculateDiscount(price int, discountPercent int) int {
    if discountPercent == 0 {
        return price
    }
    return price - (price * discountPercent / 100)
}
```

You can call this function like this:

```go
func main() {
    discount := calculateDiscount(100, 20)
    fmt.Println(discount) // Output: 80
}
```

A function declaration has 4 parts:

1. the `func` keyword
2. the function name
3. the input parameters
4. the return type

Input parameters are listed in parentheses, separated by commas. The parameter name
is listed first and the type second.

The return type is given between the closing parenthesis of the parameter list and
the opening brace of the function body.

Go uses the return keyword to return values from a function. If a function declares a
return type, it must supply a return. The Go compiler enforces this at compile time,
which helps prevent bugs. If a function returns nothing, a return isn't needed unless
you are exiting from the function before the last line.

When a function has no input parameters, use empty parentheses (()).

When a function has two or more consecutive input parameters of the same type, you
can specify the type once for all of them like this:

```go
func div(num, denom int) int {
    return num / denom
}
```

When a function returns nothing, omit the return type like this:

```go
func main() {
}
```

### Simulating Named and Optional Parameters

Go doesn't support named and optional parameters. You must supply all parameters for
a function.

Named options and optional parameters can be simulated by using a structure as
follows:

```go
type EmailOpts struct {
    To      string
    Subject string
    CC      string
}

// SendEmail sends an email with the given options.
// This is a simplified example that always returns nil.
// In a real implementation, this would return an error if sending fails.
func SendEmail(opts EmailOpts) error {
    fmt.Printf("Sending email to: %s\n", opts.To)
    fmt.Printf("Subject: %s\n", opts.Subject)
    if opts.CC != "" {
        fmt.Printf("CC: %s\n", opts.CC)
    }
    return nil
}

func main() {
    SendEmail(EmailOpts{
        To:      "admin@example.com",
        Subject: "Alert",
        CC:      "team@example.com",
    })
    SendEmail(EmailOpts{
        To:      "user@example.com",
        Subject: "Welcome",
    })
}
```

### Variadic Input Parameters and Slices

Go supports variadic parameters. The variadic parameter must be the last parameter.

A variadic parameter is identified with three dots (...) before the type.

This creates a variable within the function that's a slice of the specified type. Use
this slice like any other slice.

The following example shows a function that adds a base value to each element in a
variadic parameter and returns a new slice with the results:

```go
func addTo(base int, vals ...int) []int {
    out := make([]int, 0, len(vals))
    for _, v := range vals {
        out = append(out, base+v)
    }
    return out
}
```

This can be called in a number of ways:

```go
func main() {
    fmt.Println(addTo(3))
    fmt.Println(addTo(3, 2))
    fmt.Println(addTo(3, 2, 4, 6, 8))
    a := []int{4, 3}
    fmt.Println(addTo(3, a...))
    fmt.Println(addTo(3, []int{1, 2, 3, 4, 5}...))
}
```

You can supply however many values you want for the variadic parameter or no values
at all. The first call passes no variadic arguments and returns an empty slice. The
second call passes one value, and the third passes multiple values.

You can pass a slice to a variadic parameter by putting three dots (...) after the
variable or slice literal.

Running the above example results in the following output:

```text
[]
[5]
[5 7 9 11]
[7 6]
[4 5 6 7 8]
```

### Multiple Return Values

When a function returns multiple values, the types of the return values are listed in
parentheses, separated by commas.

If a function returns multiple values, you must return all of them, separated by
commas. Don't put parentheses around the return values.

You must assign each value returned from a function.

Go's multiple return value support is used to return an `error` if something goes
wrong. If the function completes successfully, nil is returned for the error. By
convention, the error is always the last value returned. This convention ensures
consistency across the Go ecosystem, making code more predictable and readable.

Here's an enhanced version of the earlier `addTo` function that demonstrates multiple
return values by adding error handling:

```go
func addTo(base int, vals ...int) ([]int, error) {
    out := make([]int, 0, len(vals))
    for _, v := range vals {
        // Check for overflow before performing the addition
        if v > 0 && base > math.MaxInt-v {
            return nil, fmt.Errorf("integer overflow: %d + %d", base, v)
        }
        if v < 0 && base < math.MinInt-v {
            return nil, fmt.Errorf("integer underflow: %d + %d", base, v)
        }
        out = append(out, base+v)
    }
    return out, nil
}
```

When calling a function with multiple return values, you must handle all of them:

```go
func main() {
    result, err := addTo(10, 5, 3, 7)
    if err != nil {
        fmt.Println("Error:", err)
        return
    }
    fmt.Println("Result:", result) // Output: Result: [15 13 17]
}
```

### Ignoring Return Values

If a function returns multiple values and any of the values aren't needed, assign the
unneeded values to the name _.

Go does let you implicitly ignore ALL of the return values for a function. A common
example of this is `fmt.Println` which actually returns two values.

### Named Return Values

Go allows you to specify names for your return values.

When names are given for return values, variables of those names are predeclared
within the function to hold the return values. These variables are scoped to the
function.

You must surround named return values with parentheses, even if there is only a
single return value.

If you want to name only some of the return values, you can do so by using _ as the
name for any return values you want to remain nameless.

Named return values are initialized to their zero values when created. This means
that you can return them before any explicit use or assignment.

Two problems with named return values:

1. These variables can be shadowed within the function
2. Declaring named return values doesn't mean that you have to return them.

   You can give different values in the return statement. The named return
   parameters give a way to *declare an intent* to use variables to hold the return
   values, but *doesn't require you to use them*.

!!!tip "When to Use Named Return Values"

    Use named return values when:

    - They improve documentation by clarifying what each return value represents
    - You need to initialize return values to their zero values at function start
    - Working with defer statements that need to modify return values

    Avoid named return values when:

    - The function is short and return values are obvious from context
    - There's only a single return value of a common type (like `error`)
    - You're tempted to use blank returns (never use blank returns)

### Blank Returns

If you have named return values, you can just write `return` without specifying the
values that are returned. This returns the last values assigned to the named return
values.

!!!warning

    If your function returns values, never use a blank return. It can make it very
    confusing to figure out what value is actually returned.

## Functions Are Values

The type of a function is built out of the keyword `func` and the types of the
parameters and return values. This combination is called the signature of the
function. Any function that has the exact same number and types of parameters and
return values meets the type signature.

Since functions are values in Go, you can assign them to variables, pass them as
parameters to other functions, and return them from functions. This enables powerful
programming patterns like callbacks, strategy patterns, and dependency injection.

You can assign a function to a variable and call the function with it:

```go
// Declare a function variable
var myFuncVariable func(string) int

func sumOfBytes(str string) int {
    result := 0
    for i := 0; i < len(str); i++ {
      result += int(str[i])
    }
    return result
}

func main() {
    myFuncVariable = sumOfBytes
    fmt.Println(myFuncVariable("James")) // Output: 496
}
```

### Function Type Declarations

Go allows you to define a function type using the `type` keyword. This is useful when
you have a function signature that you want to use in multiple places, such as
function parameters, return types, or variable declarations.

```go
// Declare a function type
type transformStringToInt func(string) int

func sumOfBytes(str string) int {
    result := 0
    for i := 0; i < len(str); i++ {
        result += int(str[i])
    }
    return result
}

func countVowels(str string) int {
    count := 0
    vowels := "aeiouAEIOU"
    for i := 0; i < len(str); i++ {
        for j := 0; j < len(vowels); j++ {
            if str[i] == vowels[j] {
                count++
                break
            }
        }
    }
    return count
}

// processString accepts any function matching the transformStringToInt signature
func processString(str string, transformer transformStringToInt) {
    result := transformer(str)
    fmt.Printf("Result: %d\n", result)
}

func main() {
    // Use the function type for variable declarations
    var operation transformStringToInt

    operation = sumOfBytes
    fmt.Println(operation("James")) // Output: 496

    operation = countVowels
    fmt.Println(operation("James")) // Output: 2

    // Use the function type as a parameter
    processString("Hello", sumOfBytes)   // Output: Result: 500
    processString("Hello", countVowels)  // Output: Result: 2
}
```

The benefit of using function type declarations is to define a function signature in
one place when you plan on using it multiple times. This makes your code more
maintainable. If you need to change the signature, you only need to update it in one
location.

### Anonymous Functions

Go allows you to define new functions within a function and assign them to variables.
These *inner functions* are *anonymous* because they donâ€™t have a name.

You declare an anonymous function with the keyword `func` immediately followed by the
input parameters and the other function declaration parts.

It's a compile-time error to try to put a function name between `func` and the input parameters.

```go
func main() {
    // Assign anonymous function to a variable
    double := func(x int) int {
        return x * 2
    }
    fmt.Println(double(5)) // Output: 10

    // Immediately invoked anonymous function
    fmt.Println(func(a, b int) int {
        return a + b
    }(3, 4)) // Output: 7
}
```

You don't have to assign an anonymous function to a variable. You can write them
inline and call them immediately.

```go
func main() {
    fmt.Println(func(a, b int) int {
        return a + b
    }(3, 4)) // Output: 7
}
```

Declaring anonymous functions without assigning them to variables is useful in two situations:

1. `defer` statements (covered in the [defer section](#defer))
2. launching goroutines (covered in [Chapter 12: Concurrency in Go > Goroutines](ch12#goroutines))

## Closures

In Go, functions defined inside a function can form *closures* when they reference
elements from the outer function's scope (such as variables, parameters, named return
values, or other functions). This means they're able to access and modify those outer
scope elements.

Variables declared within the inner function can shadow elements from the outer
scope.

```go
func main() {
    a := 20
    f := func() {
        fmt.Println(a) // Output: 20
        a = 30
    }
    f()
    fmt.Println(a) // Output: 30
}
```

A closure can be used to remove repetitive code within a function.

When a closure is passed to other functions or returned from a function, they allow
you to use the variables within the function outside of that function.

### Passing Functions as Parameters

Since functions are values and you can specify the type of a function using its
parameter and return types, you can pass functions as parameters into functions.

Passing functions as parameters allows you to implement patterns like the Strategy
pattern, where you can perform different operations on the same kind of data by
simply passing a different function.

```go
package main

import (
    "fmt"
    "sort"
)

func main() {
    type Person struct {
        FirstName string
        LastName  string
        Age       int
    }

    people := []Person{
        {"John", "Smith", 37},
        {"Bob", "Dole", 23},
        {"Fred", "Pont", 18},
    }
    fmt.Println(people) // Output: [{John Smith 37} {Bob Dole 23} {Fred Pont 18}]

    // sort by last name
    sort.Slice(people, func(i, j int) bool {
        return people[i].LastName < people[j].LastName
    })
    fmt.Println(people) // Output: [{Bob Dole 23} {Fred Pont 18} {John Smith 37}]

    // sort by age
    sort.Slice(people, func(i, j int) bool {
        return people[i].Age < people[j].Age
    })
    fmt.Println(people) // Output: [{Fred Pont 18} {Bob Dole 23} {John Smith 37}]
}
```

### Returning Functions from Functions

A closure not only allows you to pass functions as parameters to functions, it also
allows you to return functions from functions.

Returning a function from a function is useful when you want to create a function
with some pre-configured behavior. The returned function "remembers" the values from
the outer function's scope, even after the outer function has finished executing.

This pattern is commonly used to create function factories or to implement the
Factory pattern, where you generate specialized functions based on initial parameters.

Here's an example that returns a function that multiplies its input by a base value:

```go
func makeMult(base int) func(int) int {
    return func(factor int) int {
        return base * factor
    }
}

func main() {
    timesTwo := makeMult(2)
    timesThree := makeMult(3)
    for i := 0; i < 3; i++ {
        fmt.Println(timesTwo(i), timesThree(i))
    }
}
```

In this example, `makeMult` returns a closure that captures the `base` parameter.
Each call to `makeMult` creates a new closure with its own captured `base` value.
When you call `timesTwo(i)`, it uses the `base` value of 2, and `timesThree(i)` uses
the `base` value of 3, even though `makeMult` has already returned.

The output demonstrates how each returned function maintains its own state:

```text
0 0
2 3
4 6
```

## defer

`defer` specifies code to be run when exiting from a function, no matter how the
function exits. It's often used to cleanup temporary resources.

You can use a function, method, or closure with `defer`.

You can defer multiple functions in a Go function. When the function exits, the
deferred functions run in LIFO (Last In, First Out) order - the last deferred
function is executed first.

Deferred code runs *after* the return values are evaluated but before returning to
the caller.

!!!important "Defer Argument Evaluation"

    When you defer a function call, Go evaluates the function's arguments
    immediately at the point where `defer` is called, not when the deferred function
    actually executes. The evaluated values are then stored and used later when the
    deferred function runs.

The deferred function can return a value, but it's ignored and there is no
way to access it.

```go
func main() {
    defer fmt.Println("first")
    defer fmt.Println("second")
    fmt.Println("third")
}
```

The output demonstrates LIFO order:

```text
third
second
first
```

This example shows how parameter values are captured immediately when defer is called:

```go
func main() {
    x := 10
    defer fmt.Println("deferred:", x)
    x = 20
    fmt.Println("current:", x)
}
```

Output:

```text
current: 20
deferred: 10
```

### Resource Cleanup with defer

A common and idiomatic use of `defer` is to ensure resources are properly cleaned up,
such as closing files, releasing locks, or closing network connections. By using
`defer` immediately after acquiring a resource, you guarantee cleanup happens even if
an error occurs or the function returns early.

Here's an example of using `defer` to ensure a file is properly closed:

```go
func writeToFile(filename string, content string) error {
    file, err := os.Create(filename)
    if err != nil {
        return fmt.Errorf("failed to create file: %w", err)
    }
    defer file.Close()

    _, err = file.WriteString(content)
    if err != nil {
        return fmt.Errorf("failed to write to file: %w", err)
    }

    return nil
}
```

In this example, `defer file.Close()` is called immediately after successfully
creating the file. This ensures that:

1. The file will be closed when the function returns normally
2. The file will be closed if an error occurs during writing
3. You don't need to remember to close the file at every return point

This pattern is so common in Go that you'll see it frequently in production code. The
`defer` statement pairs the resource acquisition with its cleanup, making the code
easier to understand and maintain.

## Go is Call by Value

When you supply a variable for a parameter to a function, Go always makes a copy of
it and passes that into the function.

Because they're implemented with pointers, maps and slices have more complicated
behavior. For maps, any changes made to a map parameter are reflected in the variable
passed into the function.

For slices, you can modify any element in the slice but you can't lengthen the slice.
This is because Go copies the slice header (which contains a pointer to the
underlying array, length, and capacity), so modifications to existing elements affect
the same underlying array, but appending creates a new array that's only visible to
the function.

```go
func modMap(m map[int]string) {
    m[2] = "hello"
    m[3] = "goodbye"
    delete(m, 1)
}

func modSlice(s []int) {
    for k, v := range s {
        s[k] = v * 2
    }
    s = append(s, 10)
}

func main() {
    m := map[int]string{
        1: "first",
        2: "second",
    }
    modMap(m)
    fmt.Println(m) // Output: map[2:hello 3:goodbye]

    s := []int{1, 2, 3}
    modSlice(s)
    fmt.Println(s) // Output: [2 4 6]
}
```

Every type in Go is a value type. It's just that sometimes the value is a pointer.

## Summary: Function Patterns

| Pattern | When to Use | Example Use Case |
|---------|-------------|------------------|
| **Regular functions** | General purpose organization | Business logic |
| **Variadic parameters** | Variable number of arguments | Logging, aggregation |
| **Multiple return values** | Result + error or related values | Error handling |
| **Named return values** | Complex returns or with defer | API responses |
| **Anonymous functions** | One-time use or callbacks | Sorting, defer |
| **Closures** | Capturing outer scope | Event handlers |
| **Function types** | Reusable signatures | Strategy pattern |
| **Passing functions** | Runtime behavior selection | Callbacks, sorting |
| **Returning functions** | Creating specialized functions | Function factories |
| **defer** | Guaranteed cleanup | Closing files |
