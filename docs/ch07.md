# Chapter 7: Types, Methods, and Interfaces

Go is a statically typed language with both built-in types and user-defined types. It
allows you to attach methods to types. It also has type abstraction, allowing you to
write code that invokes methods without explicitly specifying the implementation.

Go's implementation of these concepts encourages best practices such as avoiding
inheritance and encouraging composition.

!!! note "Abstract vs Concrete Types"

    An abstract type is one that specifies what a type should do but not how it's done.
    A concrete type specifies what and how. This means that the type has a specified way
    to store its data and provides an implementation of any methods declared on the type.
    All types in Go are either abstract or concrete.

## Types in Go

Earlier you saw how to declare struct types:

```go
type Person struct {
    FirstName string
    LastName  string
    Age       int
}
```

You can use any primitive type or compound type literal to define a concrete type:

```go
type Score int
type Converter func(string)Score
type TeamScores map[string]Score
```

Go allows you to declare a type at any block level, from the package block down. You
can access the type only from within the scope it's declared. The only exceptions are
types exported from other packages.

## Methods

Go supports methods on user-defined types.

Methods for a type must be declared at the package block level in the same package as
their associated type.

```go
type Person struct {
    FirstName string
    LastName  string
    Age       int
}

func (p Person) String() string {
    return fmt.Sprintf("%s %s, age %d", p.FirstName, p.LastName, p.Age)
}
```

Method look like function declarations with one addition: the *receiver*
specification. The receiver appears between the keyword `func` and the name of the
method. Like all other variable declarations, the receiver name appears before the
type.

In the example above, the receiver specification is `(p Person)` and the method name
is `String`.

By convention, the receiver name is a short abbreviation of the type's name, usually
its first letter. It's non-idiomatic to use this or self.

Methods can not be overloaded. This means that you can't have two methods of the same
name on the same type.

### Pointer Receivers and Value Receivers

Just as Go uses pointers to indicate that a parameter might be modified, it
also uses pointers for method receivers.

A method receiver can be a *pointer receiver* or a *value receiver*.

- If your method modifies the receiver, you MUST use a *pointer receiver*
- If your method needs to handle nil instances, then you MUST use a *pointer receiver*
- If your method doesn't modify the receiver, you MAY use a *value receiver*

An example of both using a *pointer receiver* and a *value receiver*:

```go title="ch07/counter/counter.go"
--8<-- "ch07/counter/counter.go"
```

Go automatically takes the address of the local variable when calling a method that
takes a pointer receiver. In this case, `c.Increment()` is converted to
`(&c).Increment()`.

If you call a *pointer receiver* method on a `nil` instance, your code will compile but
will panic at runtime if the method tries to access any fields without first checking
for `nil`.

If you call a *value receiver* method on a `nil` pointer, the code will
panic immediately because Go can't dereference `nil` to create the value copy needed
for the value receiver.

Regardless of the receiver type, rules for passing values to functions still apply.
Parameters passed by value are copied for use inside the function.

Go encourages you to directly access struct fields rather than writing getter or
setter methods (unless needed for an interface). The exception is when you need to
update multiple fields as a single operation or when the update isn't a
straightforward assignment of a new value.

### Choosing Between Pointer and Value Receivers

While some developers prefer consistency (using all pointer receivers once any method
needs one), a more nuanced approach is often better:

- Use **value receivers** for small, immutable types or when the method doesn't modify
  the receiver. Value receivers make it clear the method is read-only and work with
  both values and pointers.
- Use **pointer receivers** when the method modifies the receiver, when the type is
  large (copying would be expensive), or when you need to handle nil instances.
- **Mixed receiver types are acceptable** when there's a clear reason for each choice.

The main consideration with mixed receivers is interface satisfaction: if your type
implements an interface, be aware that a `*Type` and `Type` are different types and
may satisfy different interfaces depending on the receiver types used.

### Code Your Methods for nil Instances

When you have a *pointer receiver*, you can write methods that handle `nil` instances
gracefully. This is useful when you want a method to work even when called on a `nil`
pointer.

```go title="ch07/inttree/inttree.go"
--8<-- "ch07/inttree/inttree.go"
```

In this example, the `Insert` method checks if the receiver is nil and handles it
appropriately. This allows you to call `Insert` on a nil tree pointer without
panicking.

### Methods are Functions Too

method value

method expression

### Functions verses Methods

### Type Declarations Aren't Inheritance

### Types Are Executable Documentation

## iota Is for Enumerationsâ€”Sometimes

## Use Embedding for Composition

## Embedding isn't Inheritance

## A Quick Lesson on Interfaces

### Interfaces Are Type-Safe Duck Typing

### Embedding and Interfaces

### Accept Interfaces, Return Structs

## Type Assertions and Type Switches

### Type Assertions

### Type Switches

## Use Type Assertions and Type Switches Sparingly

## Function Types Are a Bridge to Interfaces

## Implicit Interfaces Make Dependency Injection Easier

## Wire

## Go Isn't Particularly Object-Oriented (and That's Great)
